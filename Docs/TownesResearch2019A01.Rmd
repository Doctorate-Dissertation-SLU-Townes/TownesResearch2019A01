---
title: "R Notebook: Improving Construct Validity in Studies of Technology Transfer"
author: "Malcolm S. Townes"
date: '(`r format(Sys.time(), "%B %d, %Y")`)'
output: 
    github_document: default
    html_notebook: default
    word_document: default
    always_allow_html: yes
---

## Introduction
This is an R Notebook for an investigation of improving construct validity in studies of technology transfer.

## Project Set Up
The following code chunk enables the R Notebook to integrate seemlessly with the project organization format. This is normally included in the R Notebook to simplify file calls and enable file portability but it has been causing an error. Per Dr. Christopher Prener of Saint Louis University, the error is generated because the `here::here()` function has not been tested with certain combinations of functions. To work around this problem, I've embedded the `here()` function where I enter a file path when necessary.

```{r setup-project, echo=FALSE, warning=FALSE}
knitr::opts_knit$set(root.dir = here::here())
```

## Load Dependencies
The following code chunk loads package dependencies required to perform the necessary tasks. Basic tasks include importing, reading, wrangling, and cleaning data; selecting a subset of the data; checking for unique observations, and analyzing missing data. 
```{r load-dependencies, echo = FALSE, warning = FALSE}
library(tidyverse) # loads the basic R packages
library(here) # enables file portability
library(readr) # functions for reading data
library(dplyr) # functions for data wrangling
library(janitor) # functions for data cleaning
library(naniar) # functions for analyzing missing data
library(ggplot2) # functions for data visualizations
library(boot) # functions for regression analysis
library(ordinal) # functions for regression models for ordinal data
library(MASS) # functions for ordered logistic or probit regression
library(broom) # functions for tidying ordinal logistic regression models
library(gvlma) # functions for global validation of linear model assumptions
library(lmtest) # functions for testing linear regression models
library(leaps) # functions for regression subset selection
library(car) # companion to applied regression
library(aod) # functions to analyze overdispersed data counts and proportions
library(pscl) # contains function for McFadden's Pseudo R2 for logistic regression
```

## Load Raw Data
The following code chunk imports the raw data from the `txt` file for the NBER data set for the period 1963 to 1999.
```{r import-data, echo = FALSE, warning = FALSE}
DataRaw <- read.table(here("DataRaw","NBERpatents1963to1999/apat63_99.txt"), sep = ",", header = TRUE, fill = TRUE, dec = ".")
```

## Subset Data
The following code chunk creates a subset of the data for the period 1990 through 1995.
```{r subset-data-90-95, echo = FALSE, warning = FALSE}
DataRaw %>% # subset data
  filter(GYEAR>=1990) %>%
  filter(GYEAR<=1995) -> DataSubset90to95
DataSubset90to95 <- as_tibble(DataSubset90to95) # convert data frame to tibble
```

## Sample Data
The following code chunk takes a sample of 2,000 cases from the data subset for the period 1990 through 1995.
``` {r sample-90-95, echo = FALSE, warning = FALSE}
set.seed(1972)
Sample90to95 <- sample(1:nrow(DataSubset90to95), size = 2000, replace = TRUE, prob = NULL)
Sample90to95 <- DataSubset90to95[Sample90to95,]
Sample90to95 <- as_tibble(Sample90to95)
```

## Clean Data Phase 1
The following code chunk reorganizes the variables and eliminates variables not used in the analysis.
```{r clean-data-01, echo = FALSE, warning = FALSE}
Sample90to95 %>%
  dplyr::select(PATENT, GYEAR, CRECEIVE, CAT, CLAIMS, CMADE, GENERAL, ORIGINAL, FWDAPLAG, BCKGTLAG) -> Sample90to95A # Another package also has a `select()` function
```

## Inspect Sample Data
The following code chunk evaluates the data sample to determine if additional data cleaning is necessary.  It first checks for missing data for each variable.  It then checks for missing data for each variable in each case.  Then it checks for duplicate cases with the `PATENT` variable to determine if that variable can be used as a unique identifier for each case.  Finally, it checks for duplicate cases across all variables to ensure that each case is unique.
```{r inspect-data-90-95, echo = FALSE, warning = FALSE}
miss_var_summary(Sample90to95A, order = TRUE)
miss_case_summary(Sample90to95A, order = TRUE)
get_dupes(Sample90to95A, PATENT)
get_dupes(Sample90to95A)
```

## Adjust for Missing Data
The following code chunk modifies cases with missing data, removes duplicate cases, and then evaluates the data sample to determine if additional cleaning is necessary. It first assigns a value of `0` to instances of `NA` in the data for the `GENERAL` variable. It then assigns a value of `1` to instances of `NA` in the data for the `ORIGINAL` variable. For the `FWDAPLAG` and `BCKGTLAG` variables it assigns the maximum value in the data for each variable to instances of missing data. It then removes duplicate cases. The code chunk then checks for missing data for each variable in each case and missing data for each case. Then it checks for duplicate cases with the `PATENT` variable to determine if that variable can be used as a unique identifier for each observation.  Finally, it checks for duplicate observations across all variables to ensure that each case is unique.
```{r missing-data, echo = FALSE, warning = FALSE}
Sample90to95B <- Sample90to95A
Sample90to95B$GENERAL[is.na(x=Sample90to95B$GENERAL)] <- 0
Sample90to95B$ORIGINAL[is.na(x=Sample90to95B$ORIGINAL)] <- 1
Sample90to95B$FWDAPLAG[is.na(x=Sample90to95B$FWDAPLAG)] <- max(Sample90to95B$FWDAPLAG, na.rm = TRUE)
Sample90to95B$BCKGTLAG[is.na(x=Sample90to95B$BCKGTLAG)] <- max(Sample90to95B$BCKGTLAG, na.rm = TRUE)

Sample90to95B %>%
  distinct() -> Sample90to95B

miss_var_summary(Sample90to95B, order = TRUE)
miss_case_summary(Sample90to95B, order = TRUE)
get_dupes(Sample90to95B, PATENT)
get_dupes(Sample90to95B)
```

## Central Tendency
The following code chunk calculates measures of central tendency in the sample data for each of the variables.
```{r central-tendency, echo = FALSE, warning = FALSE}
summary(Sample90to95B)
```

## Histograms
The following code chunk displays histograms for the variables of primary interest to enable visual inspection of the data to evaluate whether or not they fit normal distributions.
```{r histograms, echo = FALSE, warning = FALSE}
histoGYEAR <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(GYEAR))
ggsave(here("results", "histogramGYEAR.png"), dpi = 300)

histoCRECEIVE <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(CRECEIVE))
ggsave(here("Results", "histogramCRECEIVE.png"), dpi = 300)

histoCAT <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(CAT))
ggsave(here("Results", "histogramCAT.png"), dpi = 300)

histoCLAIMS <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(CLAIMS))
ggsave(here("Results", "histogramCLAIMS.png"), dpi = 300)

histoCMADE <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(CMADE))
ggsave(here("Results", "histogramCMADE.png"), dpi = 300)

histoGENERAL <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(GENERAL))
ggsave(here("Results", "histogramGENERAL.png"), dpi = 300)

histoORIGINAL <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(ORIGINAL))
ggsave(here("Results", "histogramORIGINAL.png"), dpi = 300)

histoFWDAPLAG <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(FWDAPLAG))
ggsave(here("Results", "histogramFWDAPLAG.png"), dpi = 300)

histoBCKGTLAG <- ggplot() +
  geom_histogram(Sample90to95B, mapping = aes(BCKGTLAG))
ggsave(here("Results", "histogramBCKGTLAG.png"), dpi = 300)
```

## Scatter Plots
The following code chunk displays scatter plots with `CRECEIVE` as the dependent variable against each of the the primary independent variables of interest to visually inspect for linear relationships between the dependent variable and each of the independent variables.
```{r scatter-plots, echo = FALSE, warning = FALSE}
ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = GYEAR, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyGYEAR.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = CAT, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyCAT.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = CLAIMS, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyCLAIMS.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = CMADE, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyCMADE.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = GENERAL, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyGENERAL.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = ORIGINAL, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyORIGINAL.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = FWDAPLAG, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyFWDAPLAG.png"), dpi = 300)

ggplot() +
  geom_point(Sample90to95B, mapping = aes(x = BCKGTLAG, y = CRECEIVE))
ggsave(here("results", "scatterCRECEIVEbyBCKGTLAG.png"), dpi = 300)
```

## Q-Q Plots
The following code chunk displays Quantile-Quantile (Q-Q) plots to check for normal distribution in the data sample for each variable of primary interest.
```{r qq-plots, echo = FALSE, warning = FALSE}
png(filename = here("Results", "QQplotGYEAR.png"))
qqnorm(Sample90to95B$GYEAR, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for GYEAR", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$GYEAR, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotCReceive.png"))
qqnorm(Sample90to95B$CRECEIVE, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for CRECEIVE", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$CRECEIVE, col = "green", lwd = 2, plot.it = TRUE)
dev.off()

png(filename = here("Results", "QQplotCLAIMS.png"))
qqnorm(Sample90to95B$CLAIMS, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for CLAIMS", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$CLAIMS, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotCMADE.png"))
qqnorm(Sample90to95B$CMADE, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for CMADE", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$CMADE, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotGENERAL.png"))
qqnorm(Sample90to95B$GENERAL, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for GENERAL", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$GENERAL, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotORIGINAL.png"))
qqnorm(Sample90to95B$ORIGINAL, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for ORIGINAL", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$ORIGINAL, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotFWDAPLAG.png"))
qqnorm(Sample90to95B$FWDAPLAG, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for FWDAPLAG", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$FWDAPLAG, col = "green", lwd = 2)
dev.off()

png(filename = here("Results", "QQplotBCKGTLAG.png"))
qqnorm(Sample90to95B$BCKGTLAG, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for BCKGTALG", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95B$BCKGTLAG, col = "green", lwd = 2)
dev.off()
```

## Pairwise Correlation Coefficients
The following code chunk calculates the pairwise correlation coefficients for all variables in the sample data using the Pearson product-moment correlation function.
```{r cor-matrix, echo = FALSE, warning = FALSE}
print("Correlation Coefficients", quote = FALSE)
Sample90to95corrmatrix <- cor(Sample90to95B)
```

## Clean Data 2
The following code chunk creates additional variables needed for the binary logistic regression, ordinal logistic regression, and multiple regression analyses and removes variables that will not be used.  It first creates a new variable called `CRECbinary` that converts the `CRECEIVE` variable into a dichotomous variable. It then creates a series of dummy variables for the nominal `CAT` variable to use in multiple regression analysis.
```{r clean-data-02, echo = FALSE, warning = FALSE}
Sample90to95B %>%
  mutate(CRECbinary = ifelse(CRECEIVE == 0, 0, 1)) %>%
  mutate(CAT01 = ifelse(CAT == 1, 1, 0)) %>%
  mutate(CAT02 = ifelse(CAT == 2, 1, 0)) %>%
  mutate(CAT03 = ifelse(CAT == 3, 1, 0)) %>%
  mutate(CAT04 = ifelse(CAT == 4, 1, 0)) %>%
  mutate(CAT05 = ifelse(CAT == 5, 1, 0)) %>%
  mutate(CAT06 = ifelse(CAT == 6, 1, 0)) -> Sample90to95C
```

## Observation Counts 1
The following code chunk determines the number of observations for each outcome of each nominal and ordinal independent variable to determine if the sample size is large enough for logistic regression analysis, which requires at least 10 observations for the least frequent outcome for each independent variable.
```{r sample-size-01, echo = FALSE, warning = FALSE}
print("Count Observations for Each Outcome of Each Nominal and Ordinal Variable", quote = FALSE)

Sample90to95C %>%
  group_by(GYEAR) %>%
  summarize(n())

Sample90to95C %>%
  group_by(CRECEIVE) %>%
  summarize(n())

Sample90to95C %>%
  group_by(CRECbinary) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT01) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT02) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT03) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT04) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT05) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT06) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CLAIMS) %>%
  summarize(n())

Sample90to95C %>%    
  group_by(CMADE) %>%
  summarize(n())
```

## Clean Data 3
The following code chunk groups cases where the outcome level for `CRECEIVE` is greater than or equal to 15 citations cases for the logistic regression analysis because most of those outcome levels do not have enough cases individually for logistic regression analysis which requires at least 10 cases for the least frequent outcome level of each independent variable.
```{r sample-data-90-95, echo = FALSE, warning = FALSE}
Sample90to95C %>% 
  mutate(CRECordinal = ifelse (CRECEIVE>=15,15,CRECEIVE)) -> Sample90to95C
Sample90to95C <- as_tibble(Sample90to95C) # convert data frame to tibble
```

## Observation Counts 2
The following code chunk re-checks the number of observations for each outcome level of each nominal and ordinal independent variable to determine if the sample size is large enough for logistic regression analysis, which requires at least 10 observations for the least frequent outcome for each independent variable.
```{r sample-size-02, echo = FALSE, warning = FALSE}
print("Count Observations for Each Outcome of Each Nominal and Ordinal Variable", quote = FALSE)

Sample90to95C %>%
  group_by(GYEAR) %>%
  summarize(n())

Sample90to95C %>%
  group_by(CRECEIVE) %>%
  summarize(n())

Sample90to95C %>%
  group_by(CRECbinary) %>%
  summarize(n())

Sample90to95C %>%
  group_by(CRECordinal) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT01) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT02) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT03) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT04) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT05) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CAT06) %>%
  summarize(n())

Sample90to95C %>%  
  group_by(CLAIMS) %>%
  summarize(n())

Sample90to95C %>%    
  group_by(CMADE) %>%
  summarize(n())
```

## Binary Logistic Regression Analysis
The following code chunk uses the new dichotomous variable `CRECbinomial` as the dependent variable in the binary logistic regression. It then displays the results.
```{r binary-regression, echo = FALSE, warning = FALSE}
logitCRECEIVE <- glm(CRECbinary ~ GYEAR + as.factor(CAT) + CMADE + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG + BCKGTLAG, data = Sample90to95C, family = binomial, na.action = na.omit)
summary(logitCRECEIVE)
coefs <- coef(logitCRECEIVE)

# Raise e to the coefficients
print("Raise e to the Coefficients", quote = FALSE)
exp(coefs)

# Obtain the McFadden pseudo R2
print("Obtain the McFadden Pseudo R-squared", quote = FALSE)
pR2(logitCRECEIVE)

# Confidence intervals for the coefficients
print("Confidence Intervals for the Coefficients", quote = FALSE)
confint(logitCRECEIVE, level = 0.95)
```

## Ordinal Logistic Regression Analysis
The following code chunk performs an ordinal logistic regression analysis on the data sample using `CRECEIVE` as the dependent variable. It then displays the results. It performs the analysis two different ways for comparison.
```{r ordinal-regression, echo = FALSE, warning = FALSE}
CRECEIVEordinal <- clm(as.factor(CRECordinal) ~ GYEAR + as.factor(CAT) + CMADE + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG + BCKGTLAG, data = Sample90to95C)
print("Ordinal Logistic Regression Method 01", quote = FALSE)
summary(CRECEIVEordinal)

CRECEIVEordinal01 <- polr(as.factor(CRECordinal) ~ GYEAR + as.factor(CAT) + CMADE + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG + BCKGTLAG, data = Sample90to95C, Hess = TRUE, model = TRUE, method = "logistic")
print("Ordinal Logistic Regression Method 02")
summary(CRECEIVEordinal01)

coefsOrdinal <- coefficients(summary(CRECEIVEordinal))
tvalues <- summary(CRECEIVEordinal01)$coefficients[, "t value"]
pvalues <- pt(abs(tvalues),df.residual(CRECEIVEordinal01),lower.tail = FALSE)*2
pv <- pnorm(abs(tvalues), df.residual(CRECEIVEordinal01),lower.tail = FALSE)*2
coefsOrdinal <- cbind(coefsOrdinal, "p values" = round(pvalues, 5))
coefsOrdinal <- cbind(coefsOrdinal, "p values (Normal)" = round(pv, 5))
print("Ordinal Logistic Regression - P-value Calculations")
summary(coefsOrdinal)
```

## Multiple Regression Model Selection
The following code chunk performs regressions using the sequential replacement method with `CRECEIVE` as the dependent variable and subsets of the independent variables.  It then displays the summary statistics to enable identification of the best regression model.
```{r regression-subsets, echo = FALSE, warning = FALSE}
CRECregsubsets <- regsubsets(CRECEIVE ~ GYEAR + as.factor(CAT) + CMADE + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG + BCKGTLAG, data = Sample90to95C, nbest = 2, method = "exhaustive")
summary(CRECregsubsets,all.best=TRUE, matrix=TRUE)
plot(CRECregsubsets, scale = "adjr2")
```

## Multiple Regression Analysis
The following code chunk performs a multiple regression analysis on the data sample using the selected model. It then displays the results.
```{r multiple-regression, echo = FALSE, warning = FALSE}
# Regression
CRECEIVEregression <- lm(CRECEIVE ~ GYEAR + CAT02 + CAT03 + CAT04 + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG, data = Sample90to95C, na.action = na.omit)
summary(CRECEIVEregression)
```

## Check Linear Regression Assumptions
The following code chunk performs various checks to verify that the model satisfies the assumptions of linear regression.
```{r assumptions-check-01, echo = FALSE, warning = FALSE}
# Global check of linear regression assumptions
print("Perform Global Check of Linear Regression Assumptions", quote = FALSE)
par(mfrow=c(2,2))
gvlma(CRECEIVEregression)

# Residuals
CRECEIVEresid <- residuals(CRECEIVEregression)
print("Regression Residuals", quote = FALSE)
summary(CRECEIVEresid)

# Check for homoscedasticity of residuals or equal variance
# Check for normality of residuals
png(filename = here("Results", "MultRegresQQplotModelResiduals01.png"))
par(mfrow=c(2,2))
plot(CRECEIVEregression)
dev.off()

# Check for autocorrelation of residuals using Durbin-Watson test
AutoCorr <- dwtest(CRECEIVEregression)
print("Check for Autocorrelation of Residuals", quote = FALSE)
summary(AutoCorr)

# Check that the independent variables and the residuals are uncorrelated
print("Check for Correlation Among Independent Variables and Residuals", quote = FALSE)

CorrGYEAR <- cor.test(Sample90to95C$GYEAR, CRECEIVEregression$residuals)
summary(CorrGYEAR)

CorrCAT <- cor.test(Sample90to95C$CAT, CRECEIVEregression$residuals)
summary(CorrCAT)

CorrCLAIMS <- cor.test(Sample90to95C$CLAIMS, CRECEIVEregression$residuals)
summary(CorrCLAIMS)

CorrORIGINAL <- cor.test(Sample90to95C$ORIGINAL, CRECEIVEregression$residuals)
summary(CorrORIGINAL)

CorrGENERAL <- cor.test(Sample90to95C$GENERAL, CRECEIVEregression$residuals)
summary(CorrGENERAL)

CorrFWDAPLAG <- cor.test(Sample90to95C$FWDAPLAG, CRECEIVEregression$residuals)
summary(CorrFWDAPLAG)

# Check that the variability in independent variable values is positive
VarRegression <- var(Sample90to95C)
print("Check for Positive Variablity in Values of Independent Variables", quote = FALSE)
summary(VarRegression)

# Check for perfect multicollinearity among the variables
VIFregression <- vif(CRECEIVEregression)
print("Check for Mulitcollinearity Among the Variables", quote = FALSE)
summary(VIFregression)
```

## Clean Data 4
The following code chunk removes cases in which `CRECEIVE` is greater than or equal to 10 as outliers and applies a transformation to the `CRECEIVE` variable to better satisfy the assumptions of linear regression.
```{r clean-data-04, echo = FALSE, warning = FALSE}
Sample90to95C %>% 
  filter(CRECEIVE >= 10) %>%
  mutate(CRECEIVEsqrt = sqrt(CRECEIVE)) -> Sample90to95D
```

## Q-Q Plots for Transformed Variables
The following code chunk displays Quantile-Quantile (Q-Q) plots for the transformed variables to check for suitability to use in multiple regression analysis.
```{r qq-plots-transformed, echo = FALSE, warning = FALSE}
png(filename = here("Results", "QQplotCRECEIVEsqrt.png"))
qqnorm(Sample90to95D$CRECEIVEsqrt, pch = 1, frame = FALSE, 
       main = "Normal Q-Q Plot for CRECEIVEsqrt", xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
qqline(Sample90to95D$CRECEIVEsqrt, col = "green", lwd = 2)
dev.off()
```

## Multiple Regression Using Transformed Variables 
```{r multiple-regression-trfm, echo = FALSE, warning = FALSE}
# Regression
CRECEIVEregressionTrfm <- lm(CRECEIVEsqrt ~ GYEAR + CAT02 + CAT03 + CAT04 + CLAIMS + ORIGINAL + GENERAL + FWDAPLAG, data = Sample90to95D, na.action = na.omit)
summary(CRECEIVEregressionTrfm)
```

## Check Linear Regression Assumptions for Transformed Variables
The following code chunk performs various checks to verify that the model satisfies the assumptions of linear regression.
```{r assumptions-check-trfm, echo = FALSE, warning = FALSE}
# Global check of linear regression assumptions
print("Perform Global Check of Linear Regression Assumptions")
par(mfrow=c(2,2))
gvlma(CRECEIVEregressionTrfm)

# Residuals
print("Regression Residuals", quote = FALSE)
CRECEIVEresidTrfm <- residuals(CRECEIVEregressionTrfm)
summary(CRECEIVEresidTrfm)

# Check for homoscedasticity of residuals or equal variance
# Check for normality of residuals
png(filename = here("Results", "MultRegresQQplotModelResidualsTrfm.png"))
par(mfrow=c(2,2))
plot(CRECEIVEregressionTrfm)
dev.off()

# Check for autocorrelation of residuals using Durbin-Watson test
print("Check for Autocorrelation of Residuals", quote = FALSE)
AutoCorr <- dwtest(CRECEIVEregressionTrfm)
summary(AutoCorr)

# Check that the independent variables and the residuals are uncorrelated
print("Check for Correlation between Independent Variables and Residuals", quote = FALSE)
CorrGYEAR <- cor.test(Sample90to95D$GYEAR, CRECEIVEregressionTrfm$residuals)
summary(CorrGYEAR)

CorrCAT <- cor.test(Sample90to95D$CAT, CRECEIVEregressionTrfm$residuals)
summary(CorrCAT)

CorrCLAIMS <- cor.test(Sample90to95D$CLAIMS, CRECEIVEregressionTrfm$residuals)
summary(CorrCLAIMS)

CorrORIGINAL <- cor.test(Sample90to95D$ORIGINAL, CRECEIVEregressionTrfm$residuals)
summary(CorrORIGINAL)

CorrGENERAL <- cor.test(Sample90to95D$GENERAL, CRECEIVEregressionTrfm$residuals)
summary(CorrGENERAL)

CorrFWDAPLAG <- cor.test(Sample90to95D$FWDAPLAG, CRECEIVEregressionTrfm$residuals)
summary(CorrFWDAPLAG)

# Check that the variability in independent variable values is positive
print("Check for Positive Variablity of Independent Variable Values", quote = FALSE)
VarRegression <- var(Sample90to95D)
summary(VarRegression)

# Check for perfect multicollinearity among the variables
print("Check for Multicollinearity Among Variables", quote = FALSE)
VIFregression <- vif(CRECEIVEregressionTrfm)
summary(VIFregression)
```

## Save Data
The following code chunk saves the final cleaned data that was used in the analysis.
```{r save-data}
write.csv(Sample90to95C, here("Data/DataClean/NBERpatents1963to1999/NBERPatCit90to95Sample.csv"), append = FALSE)
```
